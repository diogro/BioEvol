---
title: "Tutorial Biologia Evolutiva 2016"
author: "Diogo Melo"
date: "October 12, 2016"
output:
  html_document:
    toc: true
    toc_float:           
          collapsed: true
          smooth_scroll: false
    number_sections: true
    theme: flatly
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introdução

Primeiro alguns links:

- [Roteiro para elaboração da monografia final](http://diogro.github.io/BioEvol/roteiro.html)
- [Apostila da disciplina](https://github.com/lem-usp/apostila-bio-evol/blob/master/apostila-Bio312.pdf?raw=true)

## Genética quantitativa e evolução

Neste tutorial vamos passar por todas as etapas de análise de um conjunto de dados em genética quantitativa aplicada à macroevolução. Vamos estudar quatro caracteres quantitativos medidos em cinco espécies de roedores em uma filogenía conhecida. Usando esse conjunto de dados, vamos caracterizar o padrão de modularidade em cada espécie, as diferenças nas morfologias médias, e os processos evolutivos que levaram à diferenciação atual.

O primeiro passo, como sempre, é escolher um ambiente de análise. Neste tutorial vamos usar a linguem R, mas todos os passos poderiam ser feitos num programa gráfico como excel e Systat, ou em qualquer outra linguagem de programação, como python, perl, java, C ou Haskell. A linguagem R é especialmente conveniente, primeiro por que os monitores sabem usar ela, e segundo por que existe um pacote (escrito pelos monitores) que automatiza várias dos passos da análise.

## A linguagem R

R é um ambiente de programação _open source_ criado pensando em análises estátisticas. Você pode ler um pouco mais sobre a linguagem neste [site](http://ecologia.ib.usp.br/bie5782/doku.php?id=bie5782:03_apostila:01-intro}).

### Instalando o R

Se você está utilizando um dos computadores do IB, o R já deve estar instalado. Se não, siga as instruções nesse [site](https://mran.revolutionanalytics.com/download/) para instalar o R, e opcionalmente (mas muito recomendado!) o editor de código [RStudio](https://www.rstudio.com/products/rstudio/download/).

### Rodando comandos

Ao longo desse tutorial, você sempre vai ver blocos de código que devem ser executados no ambiente R. Por exemplo, se estivessemos interessados em somar dois números poderiamos digitar:

```{r sum}
1 + 1
```

E abaixo da operação temos o resultado que o programa retorna. 

Você pode também associar valores a variáveis (chamados objetos) e utilizar esses objetos nas suas operações. O operador "=" associa um valor a um objeto:

```{r objects}
x = 1
y = 2
x + y
```
  
## Seguindo o tutorial
  
Exitem dois jeitos de seguir esse tutorial: (1) cegamente copiar e colar os comandos no R ver o resultado; ou (2) entender o que cada parte do comando executado está fazendo e assim já aprender um pouco de R de brinde. Ambas são ok! Nosso objetivo aqui é a biologia evolutiva, o R é só um acessório. Quando alguma operação no R parecer mais esotérica, vamos tentar explicar nos comentários do código ou no texto. Se não ficar claro, consulte os monitores!

## Preliminares

Para começar, precisamos instalar um pacote (chamado evolqg) e carregar os dados para a area de trabalho usando a função data. Funções no R são como pequenos conjuntos de instruções com um nome. Para executar uma função basta digitar o nome dela, com os argumentos daquela função entre parênteses. Linhas que começam com # são comentários e são ignoradas pelo R. (Para ver mais exemplos iniciais, confira [esse tutorial](http://ecologia.ib.usp.br/bie5782/doku.php?id=bie5782:03_apostila:02-entrada) do curso de pós-graduação em R oferecido pela ecologia do IB!)

```{r packagesfake, eval = FALSE}
# Instalando o pacote de genética quantitativa evolutiva
if(!require){install.packages("evolqg")}

# Carregando o pacote evolqg
library(evolqg)

# Carregando o conjunto de dados que vamos utilizar
data(dentus)
```
```{r packages, echo = FALSE}
library(evolqg)
data(dentus)
```

## Aos dados!

Com os dados carregados, podemos ver todas as medidas digitando o nome do objeto com os dados. 

Aqui vamos ver só as primeiras linhas, mas no seu computador você deve ver o conjunto completo.

```{r fake, eval = FALSE}
dentus
```
```{r dados, echo = FALSE}
head(dentus)
```

Como podemos ver, os dados estão organizados em linhas e colunas. Cada linha representa um indivíduo, e cada coluna representa um caráter. As 4 primeiras colunas são os caracteres quantitativos, e a quinta coluna contém a espécie de cada indivíduo.

Essa mesma planilha está disponível nesse [link](https://raw.githubusercontent.com/diogro/BioEvol/master/dentus2016.csv).

# Objetivos da Aula 1

Em cada aula vamos fazer algumas contas e discutir os resultados. Ao final do curso todos esses resultados devem ser compilado num relatório final.

Nessa aula vamos calcular:

1. Média de cada caráter;
2. Variância de cada caráter;
3. Coeficiente de variação de cada caráter;
2. Gráfico da distribuição de cada caráter.

## Médias e variâncias globais

Vamos começar calculando as médias globais utilizando a função sapply e a função mean. 

Os resultados não aparecem aqui, mas rodando os comandos no R você deve ser capaz de produzí-los!

```{r, eval = FALSE}
# Como a última coluna contém as espécie, 
# vamos utilizar o operador de indexação do R  [] para selecionar as colunas de 1 a 4.
# A função sapply passa todas as colunas do primeiro argumento para a função no segundo argumento. 
sapply(dentus[,1:4], mean)
```

Podemos utilizar a mesma estratégia para calcular as variâncias e desvios padrões:

```{r, eval = FALSE}
# Variâncias
sapply(dentus[,1:4], var)

# Desvios padrão
sapply(dentus[,1:4], sd)
```

Para calcular o coeficiente de variação, podemos dividir diretamente o desvio padrão pela média:

```{r, eval = FALSE}
# Objeto com os desvios padrão
dentus_sd = sapply(dentus[,1:4], sd)

# Objeto com as médias
dentus_mean = sapply(dentus[,1:4], mean)

# Cálculo do coeficiente de variação
dentus_sd/dentus_mean
```

Ou podemos criar uma função que calcula o coeficiente de variação diretamente

```{r, eval = FALSE}
# Função que calcula o coeficiente de variação
cv = function(x) sd(x)/mean(x)

# Coeficiente de variação
sapply(dentus[,1:4], cv)
```

## Médias e variâncias por espécie

Agora vamos tentar obter esses mesmos valores separando os dados pos espécie. A função aggregate vai ajudar. Essa função é muito semelhante à sapply, mas ela recebe um argumento adicional que permite utilizar uma coluna dos dados para separar os individuos em grupos. Por exemplo, para calcular a média por espécie fazemos:

```{r}
aggregate(dentus[,1:4], list(especie = dentus[,5]), mean)
```

Vc consegue seguir essa lógica e calcular as variâncias e coeficientes de variação por espécie?

## Gráficos

É sempre importantissimo visualisar os dados usando gráficos antes de fazer qualquer análise mais complexa. Vamos explorar várias possibilidades de gráficos que revelam aspectos diferentes da distribuição dos nossos dados. 

Para isso vamos carregar alguns pacotes gráficos:

### Carregando pacotes gráficos

```{r, eval = FALSE}
list_pkgs <- c("ggplot2", "GGally", "reshape2")
new_pkgs <- list_pkgs[!(list_pkgs %in% installed.packages()[,"Package"])]
if(length(new_pkgs) > 0){ install.packages(new_pkgs) }

library(evolqg)
library(ggplot2)
library(GGally)
library(reshape2)
```

### Gráficos univariados

O primeiro e mais simples talvez seja o histograma.

```{r, eval = FALSE}
ggplot(melt(dentus), aes(value, group = species, fill = species)) + 
  geom_histogram() + 
  facet_wrap(~variable, scale = "free")
```

Podemos também usar boxplots:

```{r, eval = FALSE}
ggplot(melt(dentus), aes(species, value, fill = species, group = interaction(species, variable))) + 
  geom_boxplot() + 
  facet_wrap(~variable, scale = "free")
```

Ou um chiquérrimo violin plot:

```{r, eval = FALSE}
ggplot(melt(dentus), aes(species, value, fill = species, group = interaction(species, variable))) + 
  geom_violin() + 
  facet_wrap(~variable, scale = "free")
```

### Gráficos bivariados

Outro aspecto interessante é a relação par a par das variáveis.

Por exemplo, vamos olhar para a distribuição bivariada dos dois primeiros caracteres, incluindo também uma reta de regressão por espécie:

```{r, eval = FALSE}
ggplot(dentus, aes(humerus, ulna, group = species, color = species)) + 
  geom_point() +
  geom_smooth(method = "lm", aes(group = species))
```

Vc poderia fazer esse gráfico manualmente para todos os pares de caracteres, mas a função ggpairs resume tudo isso de uma vez:

```{r, eval = FALSE}
ggpairs(dentus, mapping = aes(color = species), 
        columns = c("humerus", "ulna","femur", "tibia"))
```

# Leitura da Aula 2

- [The Ecological Significance of Correlation Pleiades](https://www.jstor.org/stable/2405824) ([pdf](https://github.com/lem-usp/site-bio208/raw/master/static/pdfs/artigos/Berg-1960.pdf))

    __Abstract:__
    The phenomenon of correlation pleiades, i.e., the presence of correlations between some quantitative characteristics of certain parts of an organism and at the same time by the absence of correlations between these and the other parts demonstrates the independence of certain developmental processes with respect to other processes within the organism. The study of correlation sets makes it possible to establish the degree of such independence. The adoption of a quantitative criterion provides an adequate basis for the comparative method in the study of stabilizing selection. Nineteen species of herbaceous plants have been studied in order to determine the variability in the degree of dependence between the dimensions of different parts of an organism. It has been established that twelve species have correlation pleiades, while seven species have no correlation pleiades with respect to the dimensions of analogous parts. In all the instances of existence of pleiades it was the flower that had become free of the correlation interdependences within the plant organism. Existence of correlation pleiades is associated with the mode of pollen transfer, involving the presence of specific insect pollinators, with adaptations to localize the pollen deposit on some definite part of the body of the pollinating insect, and with at least one of the structural features providing for such localization (zygomorphism, presence of tubular parts, lateral position of flowers, oligomerization and a rigid fixation of the number of homologous parts of a flower). Insects were the selective factor stabilizing the dimensions of those parts of flowers which participate in the process of the precise localization of pollen on the insect body. Stabilizing selection of flower dimensions created correlation pleiades for reproductive organs, as well as for vegetative parts of the same organism. The general principle underlying the origin of developmental homeostasis in the process of evolution is the discrepancy between the agencies participating in the formation of the character and the selective forces determining its function. The same principle is responsible for the origin of correlation pleiades.

# Objetivos da Aula 2

Nessa aula vamos explorar a associação presente entre os caracteres fenotípicos nas nossas populações.
Com isso vamos poder discutir questões ligadas a função, desenvolvimento e a interação das populações com a seleção natural.

Para isso, vamos calcular:

 1. A matriz de covariância fenotípica total;
 2. A matriz de covariância fenotípica pode espécie;
 3. A matriz de correlação por espécie;

Além disso, discuta:

 1. Qual o padrão modular de cada espécie? 
 2. Qual é a intensidade da associação entre os caractéres em cada espécie?
 
## Covariâncias e correlações

Para entender como a associação entre os caracteres muda entre espécies, é preciso quantifica-lá. Para isso, vamos utilizar os conceitos de covariância e correlação. A covariância entre duas variáveis é definida como a média do produto dos desvios das médias das variáveis. Ou seja, se $\overline x$ e $\overline y$ são as médias dos caracteres $x$ e $y$, a covariâncias entre eles numa população é:

$$
Cov(x, y) = \frac{1}{N} \sum_{i = 1}^{N} (x_i - \overline{x})(y_i - \overline y)
$$

Para que possamos entender essa formula intuitivamente, vamos pensar nos sinais de cada termo da soma. Em que condições o termo $(x_i - \overline{x})(y_i - \overline y)$ é positivo e contribui pra aumentar a covariância? E quando ele é negativo? Como esse termo é um produto de desvios, o produto vai ser positivo quando os dois desvios tiverem o mesmo sinal, e negativo quando os desvios tiverem sinais diferentes. Ou seja: quando tanto o caráter $x$  quando o $y$ estiverem acima ou abaixo das suas médias, o produto é positivo e contribui pra aumentar a covariância; quando $x$ é menor do que a média e $y$ é maior, ou vice-versa, o produto é negativo e contribui para diminuir a covariância. Se, ainda, os desvios não tiverem relação nenhuma, desvios na mesma direção e em direções opostas tendem a se cancelar, e a covariação será
próxima de zero. Isso está ilustrado na figura abaixo, indivíduos nas regiões em azul aumentam a covariância, enquanto indivíduos na região em amarelo diminuem a covariância.

```{r, echo = FALSE, warning=FALSE, message=FALSE }
set.seed(42)
library(ggplot2)
library(mvtnorm)
data = data.frame(rmvnorm(50, sigma = 0.8*matrix(c(1, 0.7, 0.7, 1), 2)))
ggplot(data, aes(X1, X2)) + 
   annotate("rect", xmin = Inf, xmax = 0, ymin = Inf, ymax = 0, fill= "blue", alpha = 0.5)  + 
   annotate("rect", xmin = -Inf, xmax = 0, ymin = -Inf, ymax = 0 , fill= "blue", alpha = 0.5) + 
   annotate("rect", xmin = 0, xmax = Inf, ymin = 0, ymax = -Inf, fill= "yellow", alpha = 0.5) + 
   annotate("rect", xmin = 0, xmax = -Inf, ymin = Inf, ymax = 0, fill= "yellow", alpha = 0.5) + 
   geom_point() + theme_classic() + xlim(-2,2)+ ylim(-2,2) + labs(x = "x", y = "y")
```

As covariâncias entre caracteres são quantidades muito importantes na biologia evolutiva, como vamos ver mais adiante no curso. Apesar disso, elas sofrem do mesmo problema das variâncias: dependem da escala absoluta dos caracteres sendo medidos. Assim, não podemos comparar covariâncias entre pares de caracteres que tenham escalas diferentes, e não podemos comparar as covariâncias entre os mesmo caracteres medidos em organismos que tenham escalas diferentes. Para isso, vamos definir uma segunda medida de associação que e admensional, e que pode ser comparada entre escalas: a correlação linear. Note que se medirmos a covariância de um caráter com ele mesmo, chegamos na formula da variância. A partir disso, é fácil mostrar que o valor mais alto que uma covariância pode assumir é o produto dos desvios padrão entre as variâveis medidas (afinal, a covariância máxima de um caráter é com ele mesmo, ou seja, sua variância, que é o desvio padrão ao quadrado). Então, vamos definir a correlação como a proporção da covariância máxima entre dois caracteres, ou a covariância dividido pelo produto dos desvios padrão: 

$$
Cor(x, y) = \frac{Cov(x, y)}{\sigma_x \sigma_y} = \frac{1}{N} \sum_{i = 1}^{N} \frac{(x_i - \overline{x})(y_i - \overline y)}{\sigma_x \sigma_y}
$$

Essa quantidade varia entre -1 e 1, e mede o grau de associação entre duas variáveis numa escala absoluta. Correlações próximas de 1 indicam que os caracteres variam juntos e na mesma direção; correlações próximas de -1 indicam que os caracteres variam juntos mas em direções opostas; correlações próximas de zero indicam que os caracteres são independentes. A correlação pode ser comparada entre caracteres e populações diferentes. 

## Medindo covariâncias e correlações no R

Primeiro vamos carregar os dados novamente:

```{r}
# Carregando o pacote evolqg
if(!require(evolqg)){install.packages("evolqg"); library(evolqg)}
data(dentus)
```

Agora vamos utilizar a função cov para calcular a covariância entre um par de caracteres:

```{r}
cov(dentus$humerus, dentus$ulna)
```

__Pergunta__: Esse valor de covariância é alto ou baixo? 

__Resposta__: Não faço a mais parva ideia! A covariância depende da escala! Vamos olhar para a correlação (usando a função cor), que tem escala absoluta.

```{r}
cor(dentus$humerus, dentus$ulna)
```

Esse é um valor próximo de 1, indicando alta associação entre as duas variáveis. Podemos ver isso num gráfico bivariado:

```{r, warning=FALSE, message=FALSE }
set.seed(42)
library(ggplot2)
library(mvtnorm)
ggplot(dentus, aes(humerus, ulna)) + 
   annotate("rect", xmin = Inf, xmax = mean(dentus$humerus), 
            ymin = Inf, ymax = mean(dentus$ulna), fill= "blue", alpha = 0.5)  + 
   annotate("rect", xmin = -Inf, xmax = mean(dentus$humerus), 
            ymin = -Inf, ymax = mean(dentus$ulna) , fill= "blue", alpha = 0.5) + 
   annotate("rect", xmin = mean(dentus$humerus), xmax = Inf, 
            ymin = mean(dentus$ulna), ymax = -Inf, fill= "yellow", alpha = 0.5) + 
   annotate("rect", xmin = mean(dentus$humerus), xmax = -Inf, 
            ymin = Inf, ymax = mean(dentus$ulna), fill= "yellow", alpha = 0.5) + 
   geom_point() + theme_classic()
```

A grande maioria dos pontos fica na região azul.

## Medindo várias covariâncias no R

Para que possamos comparar e interpretar a covariância ou correlação entre vários pares de caracteres simultaneamente, vamos utilizar uma notação matricial. Numa matriz de variância-covariância (ou simplesmente matriz de covariância), podemos representar todos os caracteres nas linhas e colunas, e assim, para saber a covariância entre um par de caracteres basta consultar a linha correspondente ao primeiro caráter na coluna correspondente ao segundo caráter. Para um conjunto de $p$ caracteres $\{z_1, z_2, ..., z_p\}$, podemos excrever sua matriz de covariância como:

$$
\begin{matrix}
Var(z_1) & Cov(z_1, z_2) & \cdots & Cov(z_1, z_p) \\
Cov(z_1, z_2) & Var(z_2) & \cdots & Cov(z_2, z_p) \\
\vdots & \vdots  & \ddots & \vdots                \\
Cov(z_1, z_p) & Cov(z_1, z_p) & \cdots & Var(z_p) \\
\end{matrix}
$$

No R, basta chamar a função cov num objeto com mais de uma coluna:

```{r}
cov(dentus[,1:4])
```

Essa é a matriz de covariância total (sem separação por espécie) dos nossos dados. Onde está o valor de covariância entre humero e ulna que calculamos antes? Esse valor aparece quantas vezes na matriz? Por que? Você consegue calcular agora a matriz de correlação total? Tem um jeito fácil (função cor), um médio (função cov2cor), e um difícil (na unha)!

## Medindo covariâncias de cada espécie

Agora vamos medir as covariâncias e correlações dentro de cada espécie. Para isso, vamos aprender a escolher apenas algumas linhas de uma tabela de dados no R. Suponha que eu queira ver apenas as linhas que sejam da espécie A. Posso fazer isso com o comando:

```{r, eval = FALSE}
dentus[ dentus$species == "A", ]
```

Podemos agora usar esse conjunto de dados reduzido para calcular a matriz da espécie A, e armazenar a matriz num objeto chamado cov_A:

```{r}
(cov_A = cov(dentus[ dentus$species == "A", 1:4]))
```

Siga essa mesma lógica e crie objetos para as matrizes de covariância e correlação de todas as espécies.

## Visualizando correlações

Podemos utilizar as matrizes de correlação para fazer representações gráficas da relação entre os pares de caracteres. Vamos escrever uma função (admito que meio complicada) que faça isso:

```{r, message=FALSE}
library(ggplot2)
library(reshape2)
if(!require(viridis)) install.packages("viridis")
library(viridis)
plotMatrix <- function (corMat, file = NULL) {
  diag(corMat) <- NA
  n_traits = nrow(corMat) 
  myPalette <- viridis(50)
  ## Se quiser uma paleta All American, use essa linha em vez da anterior
  #myPalette <- colorRampPalette(c("blue", "white", "red"))(n = 50)
  m.rs = melt(corMat) 
  m.rs$Var1 <- factor(m.rs$Var1, levels = m.rs$Var1[n_traits:1])
  m.rs.position = m.rs
  m.rs.position$Var1 <- as.numeric(m.rs.position$Var1)
  m.rs.position$Var2 <- as.numeric(m.rs.position$Var2)
  m.rs.position$value= round(m.rs.position$value, 2)
  m.rs.position$value[is.na(m.rs.position$value)] <- levels(m.rs$Var1)[n_traits:1]
  p <- 
    ggplot (m.rs) +
    geom_tile(aes(x = Var2, y = Var1, fill = value)) +
    scale_fill_gradientn(name = '', colours = myPalette, limits = c(-0.15, 1)) +
    labs(x = NULL, y = NULL) + 
    geom_text(data = m.rs.position, aes(x = Var2, y = Var1, label = value)) + 
    theme_bw()
  if(!is.null(file)) cowplot::save_plot(plot = p, file)
  return(p)
}
```

Agora podemos usar essa função para plotar a matriz de correlação de uma das espécies:

```{r}
cor_A = cor(dentus[ dentus$species == "A", 1:4])
plotMatrix(cor_A)
```

Olhe para todas as matrizes de correlação. Quais são os padrões modulares? Como esses padrões diferem entre as espécies? 

# Leitura da Aula 3

- [Adaptive Radiation Along Genetic Lines of Least Resistance](https://www.jstor.org/stable/2410734) ([pdf](https://github.com/lem-usp/site-bio208/raw/master/static/pdfs/artigos/Schluter%20-%201996%20-%20Adaptive%20Radiation%20Along%20Genetic%20Lines%20of%20Least%20Resistance.pdf))

    __Abstract:__
    Are measurements of quantitative genetic variation useful for predicting long-term adaptive evolution? To answer this question, I focus on gmax, the multivariate direction of greatest additive genetic variance within populations. Original data on threespine sticklebacks, together with published genetic measurements from other vertebrates, show that morphological differentiation between species has been biased in the direction of gmax for at least four million years, despite evidence that natural selection is the cause of differentiation. This bias toward the direction of evolution tends to decay with time. Rate of morphological divergence between species is inversely proportional to θ, the angle between the direction of divergence and the direction of greatest genetic variation. The direction of greatest phenotypic variance is not identical with gmax, but for these data is nearly as successful at predicting the direction of species divergence. I interpret the findings to mean that genetic variances and covariances constrain adaptive change in quantitative traits for reasonably long spans of time. An alternative hypothesis, however, cannot be ruled out: that morphological differentiation is biased in the direction gmax because divergence and gmax are both shaped by the same natural selection pressures. Either way, the results reveal that adaptive differentiation occurs principally along "genetic lines of least resistance."

# Objetivos da Aula 3

- Calcular os componentes principais de cada espécie

## Componentes principais

A tecnica de componentes princiais (também conhecida como principal component analysis ou PCA) consiste em encontrar eixos ortogonais (com angulo de 90 graus entre eles) nos quais as variáveis medidas são não correlacionadas. Em outras palavras, nós descrevemos os individuos das nossas populações usando eixos relacionados às medidas tomadas em cada individuo, então um eixo corresponde ao comprimento do humero, outro eixo ao comprimento da ulna e assim por diante. Mas nesses eixos, que tem uma interpretação biológica clara, as medidas dos individuos em cada eixo são correlacionadas. 

### Mudando os eixos

A analise de componentes principais consiste em encontrar eixos, criados a partir dos eixos originais, nos quais os individuos não são correlacionados. Antes de chegar nos componentes principais, vamos entender o que significa mudar os dados de eixos. Podemos ter, por exemplo, um eixo definido como uma combinação entre humero e ulna, e outro eixo correspondente à diferença entre humero e ulna. Vamos visualizar isso graficamente em duas dimensões, primeiro representando nos eixos originais as medidas de humero e ulna da espécie A. Vamos centralizar as medidas no zero para facilitar o gráfico, de modo que os valores nos eixos x e y vão ser diferenças das médias:

```{r, warning=FALSE, message=FALSE }
if(!require(evolqg)){install.packages("evolqg"); library(evolqg)}
data(dentus)

library(ggplot2)
# Separando e centralizando os dados da espécie A
dentus_A = as.data.frame(scale(dentus[dentus$species == "A",1:4], scale = FALSE))

# Plot de humero por ulna. Note que as duas medidas são correlacionadas 
cor(dentus$humerus, dentus$ulna)
ggplot(dentus_A, aes(humerus, ulna)) + geom_point() + theme_bw()
```

Vamos agora incluir esses dois novos eixos hipotéticos, um na direção de aumento de humero e ulna (em azul), e um na direção de aumento de humero e diminuição de ulna (em vermelho). 

```{r, warning=FALSE, message=FALSE }
ggplot(dentus_A, aes(humerus, ulna)) + geom_point() + geom_abline(intercept = 0, slope = 1, color = "blue", linetype = "dashed") + geom_abline(intercept = 0, slope = -1, color = "red", linetype = "dashed") + geom_segment(x = 0, y = 0, xend = 1, yend = 1, arrow = arrow(length = unit(0.03, "npc")), color = "blue") + geom_segment(x = 0, y = 0, xend = 1, yend = -1, arrow = arrow(length = unit(0.03, "npc")), color = "red") + theme_bw()
```

Podemos calcular as medidas de cada inviduo (scores) nesses novos eixos projetando os pontos. Para isso, temos que achar o ponto na reta que seja o mais próximo do ponto a ser projetado. Isso envolve um pouco de trigonometria, mas vamos usar essa função que encontra o ponto numa reta mais próximo de um ponto qualquer. Eu mantive o código aqui a titulo de curiosidade, não precisam se preocupar com ele:

```{r}
# A reta é definida pelos pontos p_0 e p_1, e o ponto fora da reta é o q
pontoMaisProximo <- function(q, p_0, p_1){
  A = matrix(c(p_1[1] - p_0[1], p_1[2] - p_0[2],
               p_0[2] - p_1[2], p_1[1] - p_0[1]), byrow = TRUE, ncol = 2)
  b = -1*c(-1*  q[1]*(p_1[1] - p_0[1]) -   q[2]*(p_1[2] - p_0[2]),
           -1*p_0[2]*(p_1[1] - p_0[1]) + p_0[1]*(p_1[2] - p_0[2]))
  return(c(q, solve(A, b)))
}
projecoes_blue = data.frame(t(apply(dentus_A[,1:2], 1, pontoMaisProximo, c(0, 0), c(1, 1))))
names(projecoes_blue) = c("x1", "y1", "x2", "y2")
projecoes_red = data.frame(t(apply(dentus_A[,1:2], 1, pontoMaisProximo, c(0, 0), c(1, -1))))
names(projecoes_red) = c("x1", "y1", "x2", "y2")
ggplot(dentus_A, aes(humerus, ulna)) + geom_point() + 
  geom_abline(intercept = 0, slope = 1, color = "blue", linetype = "dashed") + 
  geom_abline(intercept = 0, slope = -1, color = "red", linetype = "dashed") + 
  geom_segment(x = 0, y = 0, xend = 1, yend = 1, arrow = arrow(length = unit(0.03, "npc")), color = "blue") + 
  geom_segment(x = 0, y = 0, xend = 1, yend = -1, arrow = arrow(length = unit(0.03, "npc")), color = "red") + 
  geom_segment(data = projecoes_blue, aes(x = x1, xend = x2, y = y1, yend = y2), linetype = "dotted", color = "blue") + 
  geom_segment(data = projecoes_red, aes(x = x1, xend = x2, y = y1, yend = y2), linetype = "dotted", color = "red") + theme_bw()
```

Nós podemos também rotacionar o dados, e plotar cada individuo como se os novos eixos "compostos", o azul e o vermelho, fossem os eixos x e y:

```{r}
# Rotacionando os dados usando uma matriz de rotação
dentus_A_rot = data.frame(as.matrix(dentus_A[,1:2]) %*% matrix(c(1/sqrt(2), 1/sqrt(2), 
                                                                 1/sqrt(2), -1/sqrt(2)), 2, 2))
names(dentus_A_rot) = c("x", "y")
ggplot(dentus_A_rot, aes(x, y)) + geom_point() + 
  geom_vline(xintercept = 0, color = "red", linetype = "dashed") + 
  geom_hline(yintercept = 0, color = "blue", linetype = "dashed") + 
  geom_segment(x = 0, y = 0, xend = 0, yend = 1, arrow = arrow(length = unit(0.03, "npc")), color = "red") + 
  geom_segment(x = 0, y = 0, xend = 1, yend = 0, arrow = arrow(length = unit(0.03, "npc")), color = "blue") +theme_bw()
```

Qual será a correlação dos dados nesses novos eixos?

```{r}
cor(dentus_A_rot$x, dentus_A_rot$y)
```

Ou seja, eles ainda são correlacionados. Qual seriam os eixos que deixam nossos dados não correlacionados?

### Meu primeiro PCA

A analise de componentes principais encontra esses eixos não correlacionados usando a matriz de covariância. Por enquanto, vamos continuar com apenas duas medidas (humero e ulna da especie A) e tentar encontrar os eixos onde essas duas medidas não são correlacionadas. Para isso, vamos encontrar a matriz de covariância entre essas duas medidas:

```{r}
# matriz de covariância entre humero e ulna
cov_hu = cov(dentus_A[,1:2])
cov_hu
```

Para encontrar os componentes principais, vamos usar a função eigen:

```{r}
# Vamos usar a função eigen na matriz de covariância cov_hu
PC_hu = eigen(cov_hu)
PC_hu
```

O objeto de saida da eigen, que eu chamei de PC_hu, tem duas partes: values e vectors. O vectors é uma matriz $2\times2$, e cada coluna corresponde a um PC. O número de PCs é sempre o mesmo que o numero de eixos originais, afinal, eu precisava de 2 eixos para descrever os dados e uma rotação não vai alterar isso. Então, o primeiro componente principal da matriz de covariância entre humero e ulna é:

```{r}
# Primeiro usamos o operador $ para pegar a matriz de PCs (vectors), 
# depois o operador [,1] para pegar a primeira coluna da matriz de PCs
PC_hu$vectors[,1]
```

Vamos colocar esses eixos no gráfico, como fizemos antes com os eixos azul e vermelho (vou manter o azul e o vermelho a titulo de comparação, até que nosso chute tinha sido bom!):

```{r, warning=FALSE, message=FALSE }
PC1 = PC_hu$vectors[,1]
PC2 = PC_hu$vectors[,2]

ggplot(dentus_A, aes(humerus, ulna)) + geom_point() + 
  geom_abline(intercept = 0, slope = 1, color = "blue", linetype = "dashed") + 
  geom_abline(intercept = 0, slope = -1, color = "red", linetype = "dashed") + 
  geom_segment(x = 0, y = 0, xend = PC1[1], yend = PC1[2], arrow = arrow(length = unit(0.03, "npc")), color = "green") + 
  geom_segment(x = 0, y = 0, xend = PC2[1], yend = PC2[2], arrow = arrow(length = unit(0.03, "npc")), color = "purple") + theme_bw()
```

Agora vamos rotacionar os dados para os eixos dados pelos PCs

```{r}
# Rotacionando os dados usando os PCs
dentus_A_rot_PCs = data.frame(as.matrix(dentus_A[,1:2]) %*% PC_hu$vectors)
names(dentus_A_rot_PCs) = c("x", "y")
ggplot(dentus_A_rot_PCs, aes(x, y)) + geom_point() + 
  geom_vline(xintercept = 0, color = "purple", linetype = "dashed") + 
  geom_hline(yintercept = 0, color = "green", linetype = "dashed") + 
  geom_segment(x = 0, y = 0, xend = 0, yend = 1, arrow = arrow(length = unit(0.03, "npc")), color = "purple") + 
  geom_segment(x = 0, y = 0, xend = 1, yend = 0, arrow = arrow(length = unit(0.03, "npc")), color = "green") +theme_bw()
```

E a correlação?

```{r}
round(cor(dentus_A_rot_PCs$x, dentus_A_rot_PCs$y), 8)
```


## PCA em todas as espécies

Agora vamos partir pra um exemplo de verdade e calcular os PCs dos nossos quatro caracteres para todas as espécies. Para isso, vamos calcular novamente nossas matrizes de covariância:

```{r}
# Vamos criar uma lista com todas as nossas matrizes de uma vez só:
cov_matrices = dlply(dentus, .(species), function(x) cov(x[,1:4]))

# Agora podemos acessar cada matriz individualmente colocando no final do nome da lista 
# o operador $ seguido do nome da especie
# Por exemplo, essa é a matriz de covariância da espécie A:
cov_matrices$A
```

Para encontrar os componentes principais, vamos usar a função eigen:

```{r}
PCs_A = eigen(cov_matrices$A)
PCs_A
```

Agora o vectors é uma matriz $4\times4$ (começamos com 4 eixos), e cada coluna corresponde a um PC. Então, o primeiro componente principal de A é:

```{r}
# Primeiro usamos o operador $ para pegar a matriz de PCs (vectors), 
# depois o operador [,1] para pegar a primeira coluna da matriz de PCs
PCs_A$vectors[,1]
```

Note como todos os elementos desse componente tem o mesmo sinal e magnitude parecida. Isso significa que ao longo direção todas as medidas aumentam ou diminuem juntas. Componentes desse tipo são chamados de componentes de tamanho (size). 

Podemos olhar pra o segundo componente, que tem valores positivos para humero e ulna, e negativos para femur e tibia. Ou seja, é uma direção ao longo da qual humero e ulna aumentam enquanto femur e tibia diminuem. Esse tipo de componente é um contraste entre os dois grupos de caracteres.

## Values?

Para entender o que são os values no objeto de saida da eigen(), vamos projetar nossos dados nos PCs:

```{r}
# Rotacionando os dados usando os PCs
dentus_A_rot_PCs = as.matrix(dentus_A[,1:4]) %*% PCs_A$vectors

# Primeiras linhas dos dados rotacionados
head(dentus_A_rot_PCs)
```

Agora vamos calcular a matriz de covariância desses dados rotacionados:

```{r}
round(cov(dentus_A_rot_PCs), 10)
```
 Primeiro, note que todos os valores fora da diagonal são zero. Isso é esperado, afinal é isso que a analise de componentes principais faz: encontra eixos onde nossos dados não são correlacionados. Agora, vamos olhar para a diagonal, as variâncias dos dados rotacionados. Compare essas variâncias com os valores na parte "values" da saida da função eigen(). 
 
Comparou?

São os mesmos valores. Os values são as variâncias nas direções dos componentes principais. 

## O primeiro componente principal

Vocês leram sobre linhas de menor resistencia evolutiva no artigo do Schluter, e agora podemos entender porque essa linha corresponde ao primeiro componente principal. A quantidade de variação total na população é sempre preservada em todas essas analises que fizemos, afinal são só rotações. Para conferir isso, vamos somar as variâncias originais e somar as variâncias saindo da eigen():

```{r}
var(dentus_A$humerus) + var(dentus_A$ulna) + var(dentus_A$femur) + var(dentus_A$tibia)
sum(PCs_A$values)
```

A diferença é que usando os PCs como eixos para representar nossas variáveis, a variação é independente em cada eixo. Com isso, podemos simplesmente comparar as variâncias para saber em qual eixo está a maior parte da variação. Logo, o PC com maior variância corresponde ao eixo com maior variação fenotípica nos dados. Como evolução depende da variação disponível, a direção do primeiro componente principal é a direção que responde mais facilmente à seleção, ou seja, evolução é mais fácil ao longo do primeiro componente principal.

## PCA como analise exploratória

O objetivo dessa aula é simplesmente encontrar os PCs para todas as espécies, e vocês já sabem como faz isso nessa altura. Fora de biologia evolutiva, é comum PCA ser utilizado como uma analise exploratória e de redução dimensional. A ideia geral é sempre a mesma (encontrar eixos com variação independente), e eventualmente descrever os dados utilizando menos variáveis. É comum, por exemplo, utilizar apenas os primeiros componentes principais por que eles respondem por grande parte da variação total. 

Um uso possivel é encontrar grupos. Suponha que não soubessemos que nossos dados vem de cinco espécies distintas. Será que um PCA poderia ajudar? Vamos calcular os componentes principais da matriz de covariância total e fazer um gráfico dos scores (dados rotacionados) nos dois primeiros componentes principais:

```{r}
mat_total = cov(dentus[,1:4])
eigT = eigen(mat_total)
dentus_rot = data.frame(as.matrix(dentus[,1:4]) %*% eigT$vectors, species = dentus$species)
names(dentus_rot) = c("PC1", "PC2", "PC3", "PC4", "species")
ggplot(dentus_rot, aes(PC1, PC2)) + geom_point() + theme_bw()
```

Claramente existem grupos distintos nesses dados. Nós sabemos que eles correspondem a espécies diferentes, então vamos incluir isso como cores:

```{r}
ggplot(dentus_rot, aes(PC1, PC2, color = species)) + geom_point() + theme_bw()
```

Isso é reconfortante, mesmo sem saber as espécies de antemão conseguiriamos chegar em grupos de forma bastante satisfatória. 

Além disso, podemos ver que boa parte da diferenciação entre espécies se dá ao longo do PC1 da matriz total. Como você interpreta esse fato? __Dica__: interprete o primeiro componente da matriz de covariância total.